# NMEAParser Library

The NMEAParser Library provides functionality for parsing NMEA sentences generated by a GPS receiver.

## NMEA Sentences

NMEA sentences supply information about the GPS receiver's current location, bearing, speed, satellite count, precision, etc.

Each NMEA sentence begins with the '$' character followed by the message title/id (GPGGA, GPGLL, etc.). The message ends with a crlf preceeded by a checksum (two characters displaying the hex representation of the 8-bit XOR of all characters between (exclusive) the '$' and '\*' characters)

#### GGA - Fix information

```
$GPGGA,hhmmss.s,ddmm.m,i,dddmm.m,i,q,nn,h.h,mmm.m,M,m.m,M,,xxxx*cc

Where:
    hhmmss.s    UTC Time of Fix
    ddmm.m,i    Latitude of dd deg mm.mmm' i (N/S)
    dddmm.m,i   Longitude of ddd deg mm.mmm' i (E/W)
    q           Fix quality: 0 = invalid
                             1 = GPS fix (SPS)
                             2 = DGPS fix
                             3 = PPS fix
    	                     4 = Real Time Kinematic
    	                     5 = Float RTK
                             6 = estimated (dead reckoning) (2.3 feature)
	                         7 = Manual input mode
	                         8 = Simulation mode
    nn          Number of satellites being tracked
    h.h         Horizontal dilution of position
    m.m,M       Altitude, Meters, above mean sea level
    m.m,M       Height of geoid (mean sea level) above WGS84 ellipsoid
    xxxx        DGPS Station ID Number
    *cc         Checksum

Sample message:

$GPGGA,165358.997829,3725.0690,N,12203.3824,W,1,08,1.2,19.8,M,-32.0,M,,0000*62

```

#### GLL - Latitude/Longitude

```
$GPGLL,ddmm.m,i,dddmm.m,i,hhmmss.s,s,i*cc

Where:
    ddmm.m,i    Latitude of dd deg mm.m' i (N/S)
    dddmm.m,i   Longitude of ddd deg mm.m' (E/W)
    hhmmss.s    UTC Time of Fix
    s           Status: 'A' = valid, 'V' = invalid
    i           Mode Indicator: 'N' = data invalid
                                'A' = autonomous mode
                                'D' = differential mode
                                'E' = dead reckoning mode
                                'M' = manual input mode
                                'S' = simulator mode
    *cc         Checksum

Sample message:

$GPGLL,3725.0690,N,12203.3824,W,165358.997829,A,A*70
```

#### GSA - DOP and Active Satellites

```
$GPGSA,m,f,sv,sv,sv,sv,sv,sv,sv,sv,sv,sv,sv,sv,p.p,h.h,v.v*cc

Where:
    m        Mode: 'M' = Manual, 'A' = Automatic
    f        Fix Type:  1 = no fix
                        2 = 2D fix
                        3 = 3D fix
    sv,sv... PRNs of satellites used for fix (space for 12)
    p.p      PDOP (dilution of precision)
    h.h      Horizontal dilution of precision (HDOP)
    v.v      Vertical dilution of precision (VDOP)
    *cc      Checksum

Sample message:

$GPGSA,A,3,01,13,28,07,11,17,15,30,,,,,2.0,1.2,1.6*3B
```

#### GSV - Satellites in View

```
$GPGSV,n,s,ss,id,dd,ddd,xx,id,dd,ddd,xx,id,dd,ddd,xx,id,dd,ddd,xx*75

Where:
    n            Number of sentences for full data
    s            Sentence number
    ss           Number of satellites in view

    id           Satellite PRN number
    dd           Elevation, degrees
    ddd          Azimuth, degrees
    xx           SNR - higher is better
    *cc          Checksum

Sample messages:

$GPGSV,3,1,09,17,69,177,31,28,59,031,50,30,54,112,27,13,52,271,48*71
$GPGSV,3,2,09,19,43,197,25,15,24,305,40,11,22,055,37,01,21,073,46*76
$GPGSV,3,3,09,07,19,122,41*4B
```

#### RMC - Recommended Minimum

```
$GPRMC,hhmmss.s,s,ddmm.m,i,dddmm.m,i,sss.s,ccc.c,ddmmyy,,,m*cc

Where:
    hhmmss.s    UTC Time of Fix
    s           Status 'A' = valid or 'V' = invalid.
    ddmm.m,i    Latitude of dd deg mm.m' i (N/S)
    dddmm.m,i   Longitude ddd deg mm.m' i (E/W)
    sss.s       Speed over the ground in knots
    ccc.c       Course over the ground in degrees
    ddmmyy      UTC Date
    m           Mode Indicator: 'N' = data invalid
                                'A' = autonomous mode
                                'D' = differential mode
                                'E' = dead reckoning mode
                                'M' = manual input mode
                                'S' = simulator mode
    *cc         Checksum

Sample message:

$GPRMC,165156.997704,A,3725.0680,N,12203.3778,W,0.000,082.1,070717,,,A*41
```

#### VTG - Course and Speed

```
$GPVTG,ccc.c,T,,M,sss.s,N,sss.s,K,m*cc

Where:
    ccc.c   True track made good (degrees)
    sss.s   Ground speed, knots
    sss.s   Ground speed, Kilometers per hour
    m       Mode Indicator: 'N' = data invalid
                            'A' = autonomous mode
                            'D' = differential mode
                            'E' = dead reckoning mode
                            'M' = manual input mode
                            'S' = simulator mode
    *cc     Checksum

Sample message:

$GPVTG,082.1,T,,M,0.000,N,0.000,K,A*06
```

#### ZDA - Date and Time

```
$GPZDA,hhmmss.ss,dd,mm,yyyy,hh,mm*cc

Where:
    hhmmss  UTC Time
    dd      Day
    mm      Month
    yyyy    Year
    hh      Local zone hours -13..13
    mm      Local zone minutes 0..59
    *cc     Checksum

Sample message:

$GPZDA,165204.997712,07,07,2017,00,00*65
```

## Parsing

The parsing library parses NMEA data one sentence at a time. It identifies the type of message and then stores (using private fields) the data encoded in the message.

### Public Methods

#### bool encode(char c);

The encode method is the library's primary method for parsing NMEA data. It records chars until it reaches a newline ('\\n') character, in which case it verifies the sentence's checksum and calls <code>\_log_sentence</code>.<br>
<code>c</code> is a character read directly from the serial port<br>

Sample code
```c++
NMEAParser parser; // object initialization
...
bool newdata = false;
char c;
while (Serial.available())
{
    c = Serial.read();
    newdata = parser.encode(c); // sets newdata to true if a valid sentence has been completed
}
```

### Accessor Methods (for private fields)
#### unsigned long getTime() {return \_time;}
Returns UTC time (hhmmssss).
#### unsigned short getDate() {return \_date;}
Returns UTC date.
#### long getLatitude() {return \_latitude;}
Returns latitude in ten millionths of a degree.
#### long getLongitude() {return \_longitude;}
Returns longitude in then millionths of a degree.
#### long getAltitude() {return \_altitude;}
Returns altitude in centimeters.
#### unsigned short getPDOP() {return \_pdop;}
Returns PDOP (positional dilution of precision) scaled by 100, i.e. 120 corresponds to a DOP of 1.2.
#### unsigned short getVDOP() {return \_vdop;}
Returns VDOP (vertical dilution of precision) also scaled by 100.
#### unsigned short getHDOP() {return \_hdop;}
Returns HDOP (horizontal dilution of precision) also scaled by 100.
#### unsigned char getNSats() {return \_numsats;}
Returns the number of satellites used for GPS fix.
#### unsigned char getFixQuality() {return \_fixquality;}
Returns the fix quality (0 = invalid, 1 = GPS fix (SPS), 2 = DGPS fix, 3 = PPS fix, 4 = Real Time Kinematic, 5 = Float RTK, 6 = estimated (dead reckoning) (2.3 feature), 7 = Manual input mode, 8 = Simulation mode).
#### unsigned char getFixType() {return \_fixtype;}
Returns the fix type (1 = no fix, 2 = 2D fix, 3 = 3D fix).
#### unsigned long getSpeed() {return \_speed;}
Returns the speed in decameters (dkm) per hour.
#### unsigned short getCourse() {return \_course;}
Returns the course in hundredths of a degree.
#### unsigned long timeAge() {return \_last_time_fix;}
Returns the age of time data (in milliseconds).
#### unsigned long positionAge() {return \_last_position_fix;}
Returns the age of position data (in milliseconds).
#### unsigned char getNSatsVisible() {return \_numsats_visible;}
Returns the number of visible satellites (likely more than the amount used for fix).
#### unsigned long getSNR() {return \_snr_avg;}
Returns the average Signal to Noise Ratio (C/No, in dB) of all satellites in view (multiplied by 100).
#### unsigned char getNSNR() {return \_snr_count;}
Returns the number of satellites that have a valid SNR.

### Private Methods

#### int \_termcmp(const char \*str1, const char \*str2);

A copy of <string.h>'s strcmp.

#### int \_hexToInt(char hex);

Converts hex-formatted <code>hex</code> to an integer.

#### long \_parse_decimal(char \*p);

Parses a decimal string (with an optional decimal point) into a signed long.<br>
<code>p</code> is a pointer to the start of the decimal string.<br>
The returned <code>long</code> is equal to 100 times the number represented by the string, i.e.<br>
<code>\_parse_decimal("102.136");</code> would return 10213 (note that digits past the 100ths place are truncated).

#### long \_parse_degrees(char \*p);

Similar to <code>\_parse_decimal(char \*p)</code>, this method parses a string of numbers.
However, it expects a numeric string encoded as ddmm.mm (or dddmm.mm), where d is degrees, and m is minutes (1/60 of a degree).<br>
The returned <code>long</code> is equal to the ***decimal*** form (ie. dd.dd), in millionths of a degree.

#### bool \_log_sentence();

This method is used by <code>encode</code> to parse full sentences. It is called each time <code>encode</code> receives a newline character ('\\n').<br>
First, <code>\_log_sentence</code> records the time it was called (using <code>millis()</code>). This time is used for NMEA strings which report position or time to allow the user to determine the age of such measurements when requesting them.<br>
Next, the type of sentence is determined (<code>NMEA_GGA</code>, <code>NMEA_GSA</code>, <code>NMEA_GSV</code>, etc.). If the type is unknown, then <code>\_log_sentence</code> will exit early, returning false.<br>
The validity of each sentence is then verified (if possible; some sentences do not have validity or quality fields). If the validity test fails, then the method exits early and returns false.<br>
Finally, the data in the sentence is decoded and recorded in each sentence type's private variables.


## Extending Parsing Functionality

Currently, NMEAParser only supports GGA, GSA, GSV, and RMC NMEA messages. However, it is relatively simple to add functionality for additional messages.<br>
First, identify the sections of the sentence you wish to record/parse and create an appropriate private variable in NMEAParser.hpp.<br>
If you wish to access these variables, you should add a "get" method in NMEAParser.hpp:
```c++
inline [variabletype] get[descriptionofvariable]() {return [variablename];}
```
Replace <code>[variabletype]</code> with the type that [variablename] was declared with. <code>[descriptionofvariable]</code> should be replaced with a short, meaningful explanation of what the get function retrieves (e.g. for accessing the private <code>\_altitude</code> variable, the method getAltitude() is provided).<br>
In addition to variables for each sentence, some functionality must be added to parse the new sentence type.<br>
In each of the three sections of <code>\_log_sentence</code>, there is space indicated by a comment <code>// Add [section functionality] for additional NMEA sentences here</code>.<br>

For the first section (identification of sentence type), simply add the following code:
```c++
else if (!\_termcmp(title, \_GP<ID>\_TERM))
    sentence_type = NMEA_[ID];
```
Replace <code>[ID]</code> with the name of the NMEA sentence you wish to add functionality for.

For the second section (verification of sentence validity), add this:
```c++
case NMEA_[ID]:
    // verification code
    break;
```
Replace <code>[ID]</code> with the name of the NMEA sentence you wish to add functionality for, and add code to verify validity. If the sentence has no validity indicator like GSV or ZDA, set <code>data_valid</code> to true.

For the third section (parsing/decoding of sentence data), add the following:
```c++
case NMEA_[ID]:
    switch (term_number)
    {
        case 0: // first term in the NMEA sentence after the sentence name/title ($GPGGA, $GPGSA, etc.)
            // assign value to private sentence variable declared in NMEAParser.hpp
            break;
        ...
        case n:
            break;
    }
    break;
```
Replace <code>[ID]</code> with the name of the NMEA sentence you wish to decode.<br>
<code>p</code> points to the starting character of the term currently being decoded.
Take, for example, the sentence <code>$GPGSA,A,3,01,13,28,07,11,17,15,30,,,,,2.0,1.2,1.6*3B</code>.
Entering the <code>switch (term_number)</code> statement, with <code>term_number</code> equal to 0 (i.e. the first term after the sentence title), <code>\*p</code> would be equal to 'A'.<br>
Entering the switch statement with <code>term_number</code> equal to 1, <code>\*p</code> would be equal to '3'.<br>
